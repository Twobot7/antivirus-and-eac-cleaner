import os
import psutil
import winreg
import hashlib
import socket
import requests
import yara
import volatility3
import time
import threading
import shutil
import subprocess
from datetime import datetime
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from tqdm import tqdm
import argparse
import ctypes
import win32api
import win32con
import win32security
import platform
import logging
from colorama import init, Fore, Style
import wmi
import sys
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, BarColumn, TextColumn
from rich.prompt import Prompt
from rich.panel import Panel
from rich.table import Table
import glob
import browser_cookie3
import string
from win32api import GetLogicalDriveStrings
import win32file

# Optional imports with fallbacks
try:
    import browser_cookie3
    BROWSER_COOKIE_AVAILABLE = True
except ImportError:
    BROWSER_COOKIE_AVAILABLE = False
    logging.warning("browser_cookie3 module not available. Browser cookie cleaning will be limited.")

try:
    import volatility3
    VOLATILITY_AVAILABLE = True
except ImportError:
    VOLATILITY_AVAILABLE = False
    logging.warning("volatility3 module not available. Memory analysis will be limited.")

class MalwareScanner:
    def __init__(self):
        # Expanded list of malicious file hashes (SHA-1)
        self.malicious_hashes = {
            "e1112134b6dcc8bed54e0e34d8ac272795e73d74",
            "f1112134b6dcc8bed54e0e34d8ac272795e73d75",
            "a67311734b6dcc8bed54e0e34d8ac272795e73d77",
            "b8931134b6dcc8bed54e0e34d8ac272795e73d78",
            "c9a31134b6dcc8bed54e0e34d8ac272795e73d79",
        }
        
        # Expanded suspicious process names
        self.suspicious_processes = {
            "netcat", "mimikatz", "pwdump", "gsecdump",
            "WinSpy", "wireshark", "processhacker",
            "autoruns", "tcpview", "procexp", "procmon",
            "filemon", "regmon", "cain", "ettercap",
            "powersploit", "metasploit", "cobalt",
            "empire", "covenant"
        }

        # Known malicious IP ranges
        self.malicious_ip_ranges = [
            "185.", "192.168.", "91.234.", "185.147.",
            "194.28.", "185.220.", "46.161.", "176.119."
        ]

        # Initialize real-time monitoring
        self.observer = None
        self.monitoring = False

        # Load YARA rules
        try:
            self.rules = yara.compile(filepath='malware_rules.yar')
        except:
            print("[!] Warning: YARA rules file not found. Signature detection disabled.")
            self.rules = None

        # Add registry paths to monitor
        self.registry_paths = {
            r"Software\Microsoft\Windows\CurrentVersion\Run",
            r"Software\Microsoft\Windows\CurrentVersion\RunOnce",
            r"Software\Microsoft\Windows\CurrentVersion\RunServices",
            r"Software\Microsoft\Windows\CurrentVersion\RunServicesOnce",
            r"Software\Microsoft\Windows NT\CurrentVersion\Winlogon",
            r"Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run",
            r"Software\Microsoft\Windows\CurrentVersion\WindowsUpdate",
            r"System\CurrentControlSet\Services",
            r"System\CurrentControlSet\Control\Session Manager\KnownDLLs",
        }
        
        # Add dangerous registry entries
        self.dangerous_reg_entries = {
            "taskhost.exe", "svhost.exe", "malware", "trojan",
            "keylogger", "rootkit", "backdoor", "stealer",
            "ransomware", "crypto", "miner", "botnet"
        }

        # Initialize colorama for colored output
        init()
        
        # Setup logging
        logging.basicConfig(
            filename='malware_scan.log',
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        
        # Add more suspicious locations
        self.suspicious_locations = {
            r"C:\Windows\Temp",
            r"C:\Windows\Prefetch",
            r"C:\Windows\Debug",
            r"C:\Windows\System32\winevt\Logs",
            r"C:\Windows\System32\LogFiles",
            r"C:\Windows\System32\config",
            r"C:\Windows\Tasks",
            os.path.join(os.environ.get('USERPROFILE'), 'AppData', 'Local', 'Temp'),
            os.path.join(os.environ.get('USERPROFILE'), 'AppData', 'Roaming'),
            os.path.join(os.environ.get('USERPROFILE'), 'Recent')
        }
        
        # Add common rootkit locations
        self.rootkit_locations = {
            r"C:\Windows\System32\drivers",
            r"C:\Windows\SysWOW64\drivers",
            r"C:\Windows\System32\wbem",
            r"C:\Windows\System32\config\systemprofile"
        }

        # Initialize Rich console
        self.console = Console()
        
        # Add advanced trace locations
        self.trace_locations = {
            'System': [
                r'C:\Windows\Temp',
                r'C:\Windows\Prefetch',
                r'C:\Windows\SoftwareDistribution\Download',
                r'C:\Windows\System32\winevt\Logs',
                r'C:\Windows\System32\sru',
                r'C:\Windows\System32\wbem\Repository',
                r'C:\Windows\Debug',
                r'C:\Windows\Minidump',
                os.path.expandvars('%SystemRoot%\\Memory.dmp'),
                os.path.expandvars('%SystemRoot%\\LiveKernelReports'),
            ],
            'User': [
                os.path.expandvars('%TEMP%'),
                os.path.expandvars('%TMP%'),
                os.path.join(os.environ['USERPROFILE'], 'AppData', 'Local', 'Temp'),
                os.path.join(os.environ['USERPROFILE'], 'AppData', 'Roaming', 'Temp'),
                os.path.join(os.environ['USERPROFILE'], 'Recent'),
                os.path.join(os.environ['USERPROFILE'], 'Downloads'),
            ],
            'Browsers': {
                'Chrome': [
                    os.path.join(os.environ['LOCALAPPDATA'], 'Google', 'Chrome', 'User Data', 'Default', 'Cache'),
                    os.path.join(os.environ['LOCALAPPDATA'], 'Google', 'Chrome', 'User Data', 'Default', 'Cookies'),
                    os.path.join(os.environ['LOCALAPPDATA'], 'Google', 'Chrome', 'User Data', 'Default', 'History'),
                    os.path.join(os.environ['LOCALAPPDATA'], 'Google', 'Chrome', 'User Data', 'Default', 'Login Data'),
                ],
                'Firefox': [
                    os.path.join(os.environ['APPDATA'], 'Mozilla', 'Firefox', 'Profiles'),
                ],
                'Edge': [
                    os.path.join(os.environ['LOCALAPPDATA'], 'Microsoft', 'Edge', 'User Data', 'Default', 'Cache'),
                    os.path.join(os.environ['LOCALAPPDATA'], 'Microsoft', 'Edge', 'User Data', 'Default', 'Cookies'),
                ],
            },
            'Applications': [
                os.path.join(os.environ['LOCALAPPDATA'], 'Microsoft', 'Teams', 'Cache'),
                os.path.join(os.environ['LOCALAPPDATA'], 'Microsoft', 'Teams', 'backgrounds'),
                os.path.join(os.environ['APPDATA'], 'Zoom', 'logs'),
                os.path.join(os.environ['LOCALAPPDATA'], 'Microsoft', 'Office', '16.0', 'OfficeFileCache'),
                os.path.join(os.environ['APPDATA'], 'Discord', 'Cache'),
                os.path.join(os.environ['LOCALAPPDATA'], 'EasyAntiCheat'),
                os.path.join(os.environ['PROGRAMDATA'], 'EasyAntiCheat'),
            ],
            'Gaming': [
                os.path.join(os.environ['PROGRAMDATA'], 'Steam', 'dumps'),
                os.path.join(os.environ['PROGRAMDATA'], 'Epic', 'EasyAntiCheat'),
                os.path.join(os.environ['LOCALAPPDATA'], 'Temp', 'UnrealEngine'),
                os.path.join(os.environ['PROGRAMDATA'], 'BattlEye'),
            ],
            'Network': [
                r'C:\Windows\System32\drivers\etc\hosts',
                r'C:\Windows\System32\drivers\etc\networks',
                os.path.join(os.environ['SYSTEMROOT'], 'System32', 'winevt', 'Logs', 'Microsoft-Windows-NetworkProfile%4Operational.evtx'),
                os.path.join(os.environ['SYSTEMROOT'], 'System32', 'winevt', 'Logs', 'Microsoft-Windows-Tcpip%4Operational.evtx'),
            ]
        }

        # Add method to get all available drives
        self.drives = self._get_available_drives()
        
        # Add USB monitoring thread
        self.usb_monitoring = False
        self.usb_thread = None
        
    def _get_available_drives(self):
        """Get all available drives on the system"""
        drives = []
        drive_strings = GetLogicalDriveStrings()
        drive_letters = drive_strings.split('\000')[:-1]
        
        for drive in drive_letters:
            try:
                # Check if drive is ready/accessible
                if os.path.exists(drive):
                    drives.append(drive)
                    print(f"Found drive: {drive}")
            except:
                continue
        return drives

    def scan_all_drives(self):
        """Perform thorough scan of all drives"""
        results = []
        total_drives = len(self.drives)
        
        print(f"\n[*] Starting thorough scan of {total_drives} drives...")
        
        for drive in self.drives:
            print(f"\n[*] Scanning drive {drive}")
            try:
                # Scan drive root for malware
                results.extend(self.scan_directory(drive))
                
                # Scan system directories if present on this drive
                system_dirs = [
                    'Windows', 'Program Files', 'Program Files (x86)', 
                    'Users', 'ProgramData', 'Recovery'
                ]
                
                for dir_name in system_dirs:
                    full_path = os.path.join(drive, dir_name)
                    if os.path.exists(full_path):
                        results.extend(self.scan_directory(full_path))
                
                # Scan user profiles if present
                users_dir = os.path.join(drive, 'Users')
                if os.path.exists(users_dir):
                    for user in os.listdir(users_dir):
                        user_path = os.path.join(users_dir, user)
                        if os.path.isdir(user_path):
                            # Scan specific user directories
                            user_locations = [
                                'AppData',
                                'Downloads',
                                'Documents',
                                'Desktop',
                                'Recent',
                                'Temp'
                            ]
                            for location in user_locations:
                                path = os.path.join(user_path, location)
                                if os.path.exists(path):
                                    results.extend(self.scan_directory(path))
                
            except Exception as e:
                logging.error(f"Error scanning drive {drive}: {str(e)}")
                continue
                
        return results

    def get_admin_rights(self):
        """Request administrative privileges"""
        try:
            if ctypes.windll.shell32.IsUserAnAdmin():
                return True
            else:
                ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, " ".join(sys.argv), None, 1)
                sys.exit()
        except:
            return False

    def scan_processes(self):
        print("\n[*] Scanning running processes...")
        suspicious_found = []
        
        for proc in psutil.process_iter(['name', 'pid']):
            try:
                process_name = proc.info['name'].lower()
                if process_name in self.suspicious_processes:
                    suspicious_found.append(f"Suspicious process found: {process_name} (PID: {proc.info['pid']})")
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
                
        return suspicious_found

    def calculate_file_hash(self, filepath):
        sha1_hash = hashlib.sha1()
        try:
            with open(filepath, "rb") as f:
                for byte_block in iter(lambda: f.read(4096), b""):
                    sha1_hash.update(byte_block)
            return sha1_hash.hexdigest()
        except:
            return None

    def scan_directory(self, directory):
        print(f"\n[*] Scanning directory: {directory}")
        malicious_files = []
        
        for root, dirs, files in os.walk(directory):
            for file in files:
                filepath = os.path.join(root, file)
                file_hash = self.calculate_file_hash(filepath)
                
                if file_hash in self.malicious_hashes:
                    malicious_files.append(f"Malicious file found: {filepath}")
                    
        return malicious_files

    def check_startup_entries(self):
        print("\n[*] Checking startup entries...")
        suspicious_startup = []
        
        startup_paths = [
            r"Software\Microsoft\Windows\CurrentVersion\Run",
            r"Software\Microsoft\Windows\CurrentVersion\RunOnce"
        ]
        
        for startup_path in startup_paths:
            try:
                key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, startup_path, 0, winreg.KEY_READ)
                i = 0
                while True:
                    try:
                        name, value, _ = winreg.EnumValue(key, i)
                        if any(susp in value.lower() for susp in ["temp", "downloads", "appdata"]):
                            suspicious_startup.append(f"Suspicious startup entry: {name} -> {value}")
                        i += 1
                    except WindowsError:
                        break
            except:
                continue
                
        return suspicious_startup

    def check_network_connections(self):
        print("\n[*] Checking network connections...")
        suspicious_connections = []
        
        for conn in psutil.net_connections():
            try:
                if conn.status == 'ESTABLISHED':
                    remote_ip = conn.raddr.ip
                    # Check if connection is to known malicious IP (you should expand this list)
                    if remote_ip.startswith(('185.', '192.168.')):  # Example suspicious IP ranges
                        suspicious_connections.append(f"Suspicious connection: {remote_ip}:{conn.raddr.port}")
            except:
                continue
                
        return suspicious_connections

    def scan_memory(self, pid):
        """Scan process memory for malicious patterns"""
        try:
            process = psutil.Process(pid)
            memory_maps = process.memory_maps()
            
            for mmap in memory_maps:
                try:
                    if self.rules:
                        matches = self.rules.match(data=mmap.read())
                        if matches:
                            return f"Suspicious memory pattern in PID {pid}: {matches}"
                except:
                    continue
        except:
            pass
        return None

    def detect_rootkits(self):
        """Basic rootkit detection"""
        print("\n[*] Checking for rootkit indicators...")
        suspicious_items = []

        # Check for hidden processes
        visible_pids = set(p.pid for p in psutil.process_iter())
        all_pids = set(range(max(visible_pids)))
        hidden_pids = all_pids - visible_pids
        
        if hidden_pids:
            suspicious_items.append(f"Possible hidden processes: {hidden_pids}")

        # Check for common rootkit files
        rootkit_paths = [
            r"C:\Windows\System32\drivers\rootkit.sys",
            r"C:\Windows\System32\drivers\hidden.sys",
            r"C:\Windows\System32\drivers\hook.sys"
        ]
        
        for path in rootkit_paths:
            if os.path.exists(path):
                suspicious_items.append(f"Possible rootkit file found: {path}")

        return suspicious_items

    def behavioral_analysis(self, pid):
        """Analyze process behavior"""
        suspicious_behaviors = []
        try:
            process = psutil.Process(pid)
            
            # Check CPU usage
            if process.cpu_percent(interval=1) > 80:
                suspicious_behaviors.append(f"High CPU usage: {pid}")
            
            # Check file operations
            for file in process.open_files():
                if any(susp in file.path.lower() for susp in ['temp', 'windows', 'system32']):
                    suspicious_behaviors.append(f"Suspicious file access: {pid} -> {file.path}")
            
            # Check network connections
            for conn in process.connections():
                if conn.status == 'ESTABLISHED':
                    suspicious_behaviors.append(f"Active network connection: {pid} -> {conn.raddr}")
                    
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            pass
            
        return suspicious_behaviors

    class FileMonitor(FileSystemEventHandler):
        """Real-time file system monitoring"""
        def __init__(self, scanner):
            self.scanner = scanner

        def on_created(self, event):
            if not event.is_directory:
                file_hash = self.scanner.calculate_file_hash(event.src_path)
                if file_hash in self.scanner.malicious_hashes:
                    print(f"\n[!] ALERT: Malicious file created: {event.src_path}")

        def on_modified(self, event):
            if not event.is_directory:
                file_hash = self.scanner.calculate_file_hash(event.src_path)
                if file_hash in self.scanner.malicious_hashes:
                    print(f"\n[!] ALERT: Malicious file modified: {event.src_path}")

    def start_monitoring(self):
        """Start real-time file system monitoring"""
        if not self.monitoring:
            self.observer = Observer()
            event_handler = self.FileMonitor(self)
            
            paths_to_monitor = [
                os.path.expanduser("~"),
                os.environ.get("TEMP", ""),
                r"C:\Windows\System32"
            ]
            
            for path in paths_to_monitor:
                if os.path.exists(path):
                    self.observer.schedule(event_handler, path, recursive=True)
            
            self.observer.start()
            self.monitoring = True
            print("\n[+] Real-time monitoring started")

    def stop_monitoring(self):
        """Stop real-time file system monitoring"""
        if self.monitoring and self.observer:
            self.observer.stop()
            self.observer.join()
            self.monitoring = False
            print("\n[+] Real-time monitoring stopped")

    def clear_temp_files(self):
        """Clear all temporary files from various Windows temp locations"""
        print("\n[*] Clearing temporary files...")
        temp_locations = [
            os.environ.get('TEMP'),
            os.environ.get('TMP'),
            r'C:\Windows\Temp',
            r'C:\Windows\Prefetch',
            os.path.join(os.environ.get('USERPROFILE'), 'AppData', 'Local', 'Temp')
        ]
        
        files_removed = 0
        total_size = 0
        
        for temp_loc in temp_locations:
            if not os.path.exists(temp_loc):
                continue
                
            print(f"\n[*] Cleaning {temp_loc}")
            for root, dirs, files in os.walk(temp_loc, topdown=False):
                for name in files:
                    try:
                        file_path = os.path.join(root, name)
                        size = os.path.getsize(file_path)
                        os.remove(file_path)
                        files_removed += 1
                        total_size += size
                    except Exception as e:
                        continue

                for name in dirs:
                    try:
                        dir_path = os.path.join(root, name)
                        shutil.rmtree(dir_path, ignore_errors=True)
                    except Exception as e:
                        continue
                        
        print(f"\n[+] Removed {files_removed} files ({total_size / 1024 / 1024:.2f} MB)")
        return files_removed, total_size

    def clean_registry(self):
        """Clean potentially dangerous registry entries"""
        print("\n[*] Scanning and cleaning registry...")
        cleaned_entries = []
        
        for reg_path in self.registry_paths:
            try:
                # Try HKLM first
                for hive in [winreg.HKEY_LOCAL_MACHINE, winreg.HKEY_CURRENT_USER]:
                    try:
                        key = winreg.OpenKey(hive, reg_path, 0, 
                                           winreg.KEY_ALL_ACCESS | winreg.KEY_WOW64_64KEY)
                        
                        # Enumerate all values
                        i = 0
                        while True:
                            try:
                                name, value, _ = winreg.EnumValue(key, i)
                                
                                # Check if entry looks suspicious
                                if any(dangerous in value.lower() for dangerous in self.dangerous_reg_entries):
                                    winreg.DeleteValue(key, name)
                                    cleaned_entries.append(f"Removed suspicious registry entry: {reg_path}\\{name}")
                                
                                # Check for unusual paths
                                if value.lower().endswith(('.tmp', '.temp')) or \
                                   'temp' in value.lower() or \
                                   'downloads' in value.lower():
                                    winreg.DeleteValue(key, name)
                                    cleaned_entries.append(f"Removed suspicious path entry: {reg_path}\\{name}")
                                
                                i += 1
                            except WindowsError:
                                break
                                
                        winreg.CloseKey(key)
                    except WindowsError:
                        continue
                        
            except Exception as e:
                print(f"Error accessing registry path {reg_path}: {str(e)}")
                continue
                
        return cleaned_entries

    def advanced_memory_scan(self, pid):
        """Advanced memory scanning with pattern matching"""
        suspicious_patterns = []
        try:
            process = psutil.Process(pid)
            
            # Get memory maps
            maps = process.memory_maps(grouped=False)
            
            for mmap in maps:
                try:
                    # Look for common malware patterns in memory
                    memory_data = mmap.read()
                    
                    # Check for encoded PowerShell commands
                    if b'powershell -enc' in memory_data.lower():
                        suspicious_patterns.append(f"Encoded PowerShell command found in PID {pid}")
                    
                    # Check for common exploit patterns
                    if b'shellcode' in memory_data.lower() or b'\x90\x90\x90\x90' in memory_data:
                        suspicious_patterns.append(f"Possible shellcode/NOP sled found in PID {pid}")
                    
                    # Check for common encryption/compression artifacts
                    if b'AES' in memory_data or b'RC4' in memory_data:
                        suspicious_patterns.append(f"Encryption artifacts found in PID {pid}")
                        
                except Exception:
                    continue
                    
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            pass
            
        return suspicious_patterns

    def deep_clean_traces(self):
        """Enhanced deep cleaning of all possible traces"""
        print("\n[*] Starting comprehensive trace cleanup...")
        cleaned_items = []
        
        try:
            # 1. Stop EasyAntiCheat service if running
            try:
                subprocess.run(['sc', 'stop', 'EasyAntiCheat'], capture_output=True)
            except:
                pass

            # 2. Clean Browser Data
            cleaned_items.extend(self._clean_browser_data())

            # 3. Clean System Traces
            for category, locations in self.trace_locations.items():
                if category == 'Browsers':
                    continue  # Already handled above
                
                print(f"\n[*] Cleaning {category} traces...")
                if isinstance(locations, dict):
                    for app, paths in locations.items():
                        for path in paths:
                            cleaned_items.extend(self._clean_location(path))
                else:
                    for location in locations:
                        cleaned_items.extend(self._clean_location(location))

            # 4. Clean Windows Event Logs
            cleaned_items.extend(self._clean_event_logs())

            # 5. Clean Registry Traces
            cleaned_items.extend(self._clean_registry_traces())

            # 6. Clean Additional Gaming Traces
            cleaned_items.extend(self._clean_gaming_traces())

        except Exception as e:
            logging.error(f"Error in deep_clean_traces: {str(e)}")

        return cleaned_items

    def _clean_browser_data(self):
        """Clean browser cookies and data"""
        cleaned = []
        
        if not BROWSER_COOKIE_AVAILABLE:
            print("[!] browser_cookie3 module not available. Using alternative cleaning method...")
            # Alternative browser cleaning method
            browser_paths = {
                'Chrome': os.path.join(os.environ['LOCALAPPDATA'], 'Google', 'Chrome', 'User Data', 'Default'),
                'Firefox': os.path.join(os.environ['APPDATA'], 'Mozilla', 'Firefox', 'Profiles'),
                'Edge': os.path.join(os.environ['LOCALAPPDATA'], 'Microsoft', 'Edge', 'User Data', 'Default')
            }
            
            for browser, path in browser_paths.items():
                if os.path.exists(path):
                    try:
                        # Clean cookies
                        cookies_file = os.path.join(path, 'Cookies')
                        if os.path.exists(cookies_file):
                            try:
                                os.remove(cookies_file)
                                cleaned.append(f"Removed {browser} cookies file")
                            except:
                                pass
                        
                        # Clean cache
                        cache_path = os.path.join(path, 'Cache')
                        if os.path.exists(cache_path):
                            shutil.rmtree(cache_path, ignore_errors=True)
                            cleaned.append(f"Cleared {browser} cache")
                            
                    except Exception as e:
                        logging.error(f"Error cleaning {browser} data: {str(e)}")
            
            return cleaned
            
        try:
            # Original browser_cookie3 implementation
            # Chrome
            chrome_cookies = browser_cookie3.chrome()
            for cookie in chrome_cookies:
                try:
                    cookie.expire()
                    cleaned.append(f"Removed Chrome cookie: {cookie.domain}")
                except:
                    continue

            # Firefox
            firefox_cookies = browser_cookie3.firefox()
            for cookie in firefox_cookies:
                try:
                    cookie.expire()
                    cleaned.append(f"Removed Firefox cookie: {cookie.domain}")
                except:
                    continue

        except Exception as e:
            logging.error(f"Error clearing browser cookies: {str(e)}")

        return cleaned

    def _clean_location(self, path):
        """Clean a specific location"""
        cleaned = []
        if not os.path.exists(path):
            return cleaned

        try:
            if os.path.isfile(path):
                os.remove(path)
                cleaned.append(f"Removed file: {path}")
            else:
                shutil.rmtree(path, ignore_errors=True)
                cleaned.append(f"Removed directory: {path}")
                os.makedirs(path, exist_ok=True)  # Recreate empty directory
        except Exception as e:
            logging.error(f"Error cleaning {path}: {str(e)}")

        return cleaned

    def _clean_event_logs(self):
        """Clean Windows Event Logs"""
        cleaned = []
        try:
            subprocess.run(['wevtutil', 'cl', 'System'], capture_output=True)
            subprocess.run(['wevtutil', 'cl', 'Application'], capture_output=True)
            subprocess.run(['wevtutil', 'cl', 'Security'], capture_output=True)
            cleaned.append("Cleared Windows Event Logs")
        except Exception as e:
            logging.error(f"Error clearing event logs: {str(e)}")
        return cleaned

    def _clean_registry_traces(self):
        """Clean registry traces"""
        cleaned = []
        
        registry_locations = [
            (winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU"),
            (winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Windows\CurrentVersion\Explorer\TypedPaths"),
            (winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs"),
            (winreg.HKEY_CURRENT_USER, r"Software\EasyAntiCheat"),
        ]

        for hkey, location in registry_locations:
            try:
                winreg.DeleteKey(hkey, location)
                cleaned.append(f"Cleaned registry location: {location}")
            except:
                continue

        return cleaned

    def _clean_gaming_traces(self):
        """Clean gaming-related traces"""
        cleaned = []
        
        # EasyAntiCheat specific cleanup
        eac_locations = [
            os.path.join(os.environ['LOCALAPPDATA'], 'EasyAntiCheat'),
            os.path.join(os.environ['PROGRAMDATA'], 'EasyAntiCheat'),
            r'C:\Program Files (x86)\EasyAntiCheat\EasyAntiCheat.sys',
        ]

        for location in eac_locations:
            if os.path.exists(location):
                try:
                    if os.path.isfile(location):
                        os.remove(location)
                    else:
                        shutil.rmtree(location, ignore_errors=True)
                    cleaned.append(f"Removed EAC trace: {location}")
                except:
                    continue

        return cleaned

    def advanced_rootkit_scan(self):
        """Advanced rootkit detection and cleaning"""
        print(f"{Fore.CYAN}[*] Performing advanced rootkit scan...{Style.RESET_ALL}")
        suspicious_items = []

        # Check for hidden processes using direct API calls
        try:
            # Get handle to snapshot of processes
            hSnapshot = win32api.CreateToolhelp32Snapshot(win32con.TH32CS_SNAPPROCESS, 0)
            pe = win32api.Process32First(hSnapshot)
            
            visible_pids = set()
            while pe:
                visible_pids.add(pe.th32ProcessID)
                pe = win32api.Process32Next(hSnapshot)
                
            # Compare with psutil processes
            psutil_pids = set(p.pid for p in psutil.process_iter())
            hidden_pids = psutil_pids - visible_pids
            
            if hidden_pids:
                suspicious_items.append(f"Hidden processes detected: {hidden_pids}")
        except Exception as e:
            logging.error(f"Error in rootkit process scan: {str(e)}")

        # Check for hidden files and alternate data streams
        for location in self.rootkit_locations:
            if os.path.exists(location):
                try:
                    # Check for hidden attributes
                    for root, dirs, files in os.walk(location):
                        for item in files + dirs:
                            full_path = os.path.join(root, item)
                            try:
                                attrs = win32api.GetFileAttributes(full_path)
                                if attrs & win32con.FILE_ATTRIBUTE_HIDDEN:
                                    suspicious_items.append(f"Hidden item found: {full_path}")
                                    # Try to remove hidden attribute
                                    win32api.SetFileAttributes(full_path, win32con.FILE_ATTRIBUTE_NORMAL)
                            except:
                                continue
                except Exception as e:
                    logging.error(f"Error scanning {location}: {str(e)}")

        return suspicious_items

    def display_menu(self):
        """Display enhanced interactive menu"""
        table = Table(title="Malware Scanner Options", show_header=False, border_style="cyan")
        table.add_column("Option", style="green")
        table.add_column("Description", style="white")
        
        options = [
            ("1", "Quick Scan (Process and Memory)"),
            ("2", "Full System Scan"),
            ("3", "Custom Scan"),
            ("4", "Emergency Cleanup"),
            ("5", "System Optimization"),
            ("6", "View Scan History"),
            ("7", "Exit")
        ]
        
        for option, description in options:
            table.add_row(option, description)
            
        self.console.print(Panel(table))
        
        return Prompt.ask("Select an option", choices=[str(i) for i in range(1, 8)])

    def system_optimization(self):
        """Perform system optimization tasks"""
        self.console.print("[bold cyan]Starting System Optimization...[/]")
        results = []
        
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
        ) as progress:
            
            # Clear system caches
            task1 = progress.add_task("[cyan]Clearing system caches...", total=100)
            self.clear_system_caches()
            progress.update(task1, advance=100)
            
            # Optimize registry
            task2 = progress.add_task("[cyan]Optimizing registry...", total=100)
            self.optimize_registry()
            progress.update(task2, advance=100)
            
            # Clean system logs
            task3 = progress.add_task("[cyan]Cleaning system logs...", total=100)
            self.clean_system_logs()
            progress.update(task3, advance=100)
            
            # Disable unnecessary services
            task4 = progress.add_task("[cyan]Optimizing services...", total=100)
            self.optimize_services()
            progress.update(task4, advance=100)
        
        return results

    def clear_system_caches(self):
        """Clear various system caches"""
        cache_locations = [
            r'C:\Windows\SoftwareDistribution\Download',
            r'C:\Windows\Installer',
            r'C:\ProgramData\Microsoft\Windows\WER',
            os.path.join(os.environ['LOCALAPPDATA'], 'Microsoft\\Windows\\Explorer'),
            os.path.join(os.environ['LOCALAPPDATA'], 'Microsoft\\Windows\\INetCache'),
        ]
        
        for location in cache_locations:
            try:
                if os.path.exists(location):
                    shutil.rmtree(location, ignore_errors=True)
            except Exception as e:
                logging.error(f"Error clearing cache {location}: {str(e)}")

    def optimize_registry(self):
        """Perform registry optimization"""
        try:
            # Run built-in Windows registry optimizer
            subprocess.run(['reg', 'clean', 'HKLM', '/s'], capture_output=True)
            
            # Remove obsolete software entries
            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall", 
                              0, winreg.KEY_ALL_ACCESS) as key:
                i = 0
                while True:
                    try:
                        name = winreg.EnumKey(key, i)
                        try:
                            winreg.DeleteKey(key, name)
                        except:
                            pass
                        i += 1
                    except WindowsError:
                        break
        except Exception as e:
            logging.error(f"Error optimizing registry: {str(e)}")

    def clean_system_logs(self):
        """Clean various system log files"""
        log_files = [
            r'C:\Windows\System32\winevt\Logs\Application.evtx',
            r'C:\Windows\System32\winevt\Logs\System.evtx',
            r'C:\Windows\System32\winevt\Logs\Security.evtx',
        ]
        
        try:
            # Clear Windows Event Logs
            subprocess.run(['wevtutil', 'cl', 'System'], capture_output=True)
            subprocess.run(['wevtutil', 'cl', 'Application'], capture_output=True)
            subprocess.run(['wevtutil', 'cl', 'Security'], capture_output=True)
            
            # Delete old log files
            for log_file in log_files:
                if os.path.exists(log_file):
                    try:
                        os.remove(log_file)
                    except:
                        pass
        except Exception as e:
            logging.error(f"Error cleaning logs: {str(e)}")

    def optimize_services(self):
        """Optimize Windows services"""
        unnecessary_services = [
            'DiagTrack',  # Connected User Experiences and Telemetry
            'dmwappushservice',  # WAP Push Message Routing Service
            'MapsBroker',  # Downloaded Maps Manager
            'lfsvc',  # Geolocation Service
            'SharedAccess',  # Internet Connection Sharing
        ]
        
        try:
            for service in unnecessary_services:
                try:
                    subprocess.run(['sc', 'config', service, 'start=disabled'], capture_output=True)
                    subprocess.run(['sc', 'stop', service], capture_output=True)
                except:
                    continue
        except Exception as e:
            logging.error(f"Error optimizing services: {str(e)}")

    def view_scan_history(self):
        """Display scan history"""
        history_files = glob.glob("scan_results_*.txt")
        if not history_files:
            self.console.print("[red]No scan history found[/]")
            return
            
        table = Table(title="Scan History", show_header=True)
        table.add_column("Date", style="cyan")
        table.add_column("Findings", style="white")
        
        for history_file in sorted(history_files, reverse=True)[:5]:
            try:
                with open(history_file, 'r') as f:
                    content = f.read()
                    date = history_file.split('_')[2].split('.')[0]
                    findings = len([line for line in content.split('\n') if line.strip()])
                    table.add_row(date, str(findings))
            except:
                continue
                
        self.console.print(table)

    def interactive_scan(self):
        """Interactive scan with user-selected options"""
        print(f"\n{Fore.GREEN}=== Malware Scanner Options ==={Style.RESET_ALL}")
        print("1. Quick Scan (Process and Memory)")
        print("2. Full System Scan")
        print("3. Custom Scan")
        print("4. Emergency Cleanup")
        print("5. System Optimization")
        print("6. View Scan History")
        print("7. Exit")

        choice = input("\nSelect an option (1-7): ")

        if choice == '1':
            self.quick_scan()
        elif choice == '2':
            self.full_scan()
        elif choice == '3':
            self.custom_scan()
        elif choice == '4':
            self.emergency_cleanup()
        elif choice == '5':
            self.system_optimization()
        elif choice == '6':
            self.view_scan_history()
        elif choice == '7':
            sys.exit()
        else:
            print("Invalid choice!")

    def quick_scan(self):
        """Quick scan of processes and memory"""
        results = []
        
        with tqdm(total=3, desc="Quick Scan Progress") as pbar:
            results.extend(self.scan_processes())
            pbar.update(1)
            
            results.extend(self.check_network_connections())
            pbar.update(1)
            
            results.extend(self.detect_rootkits())
            pbar.update(1)
            
        self.save_results(results)

    def full_scan(self):
        """Enhanced comprehensive system scan"""
        results = []
        total_steps = 8  # Increased steps
        
        with tqdm(total=total_steps, desc="Full System Scan Progress") as pbar:
            # Scan all drives first
            results.extend(self.scan_all_drives())
            pbar.update(1)
            
            # Clear temp files and registry
            files_removed, space_cleared = self.clear_temp_files()
            results.append(f"Cleaned {files_removed} temporary files ({space_cleared / 1024 / 1024:.2f} MB)")
            pbar.update(1)
            
            # Clean registry
            registry_cleaned = self.clean_registry()
            results.extend(registry_cleaned)
            pbar.update(1)
            
            # Process and memory scans
            results.extend(self.scan_processes())
            pbar.update(1)
            
            # Advanced rootkit scan
            results.extend(self.advanced_rootkit_scan())
            pbar.update(1)
            
            # Network and startup checks
            results.extend(self.check_network_connections())
            results.extend(self.check_startup_entries())
            pbar.update(1)
            
            # Deep cleaning
            results.extend(self.deep_clean_traces())
            pbar.update(1)
            
            # Additional security checks
            results.extend(self.check_system_integrity())
            pbar.update(1)
            
        self.save_results(results)
        return results

    def check_system_integrity(self):
        """Check system file and security integrity"""
        results = []
        
        try:
            # Run system file checker
            print("\n[*] Checking system file integrity...")
            sfc_result = subprocess.run(['sfc', '/verifyonly'], capture_output=True, text=True)
            if "Windows Resource Protection found integrity violations" in sfc_result.stdout:
                results.append("System file integrity violations detected")
            
            # Check Windows security features
            print("[*] Checking security features...")
            
            # Check Windows Defender status
            defender_status = subprocess.run(
                ['powershell', 'Get-MpComputerStatus'], 
                capture_output=True, 
                text=True
            )
            if "AMServiceEnabled : False" in defender_status.stdout:
                results.append("Warning: Windows Defender service is disabled")
            
            # Check firewall status
            firewall_status = subprocess.run(
                ['netsh', 'advfirewall', 'show', 'allprofiles'], 
                capture_output=True, 
                text=True
            )
            if "State                                 OFF" in firewall_status.stdout:
                results.append("Warning: Windows Firewall is disabled")
            
            # Check for pending Windows updates
            update_status = subprocess.run(
                ['powershell', 'Get-WUHistory'], 
                capture_output=True, 
                text=True
            )
            if "KB" in update_status.stdout:
                results.append("Pending Windows updates detected")
                
        except Exception as e:
            logging.error(f"Error checking system integrity: {str(e)}")
            
        return results

    def custom_scan(self, selected_options=None):
        """Enhanced custom scan with all new scanning capabilities"""
        print("Starting custom scan...")
        
        if not selected_options:
            selected_options = [
                "process", "memory", "registry", "network", 
                "rootkit", "directory", "cleanup", "network_reset", 
                "cache_clear", "drive_scan", "memory_dump",
                "scheduled_tasks", "alt_streams", "drivers", "usb_monitor"
            ]
        
        scan_functions = {
            "process": self._scan_processes,
            "memory": self._scan_memory,
            "registry": self._scan_registry,
            "network": self._scan_network,
            "rootkit": self._scan_rootkit,
            "directory": self._scan_directory,
            "cleanup": self._cleanup_traces,
            "network_reset": self.reset_network_adapters,
            "cache_clear": self.clear_all_cache,
            "drive_scan": self.scan_all_drives,
            "memory_dump": self.analyze_memory_dump,
            "scheduled_tasks": self.scan_scheduled_tasks,
            "alt_streams": self.scan_alternate_data_streams,
            "drivers": self.verify_drivers,
            "usb_monitor": self.monitor_usb_drives
        }
        
        results = []
        for option in selected_options:
            if option in scan_functions:
                print(f"\n[*] Running {option}...")
                scan_result = scan_functions[option]()
                if scan_result:
                    results.extend(scan_result)
                    
        return results
        
    def _scan_processes(self):
        print("Scanning processes...")
        return []
        
    def _scan_memory(self):
        print("Scanning memory...")
        return []
        
    def _scan_registry(self):
        print("Scanning registry...")
        return []
        
    def _scan_network(self):
        print("Scanning network...")
        return []
        
    def _scan_rootkit(self):
        print("Scanning for rootkits...")
        return []
        
    def _scan_directory(self):
        print("Scanning directories...")
        return []
        
    def _cleanup_traces(self):
        print("Cleaning up traces...")
        return []

    def run_scan(self):
        """Enhanced main scanning function with new features"""
        print("[+] Starting advanced malware scan...")
        results = []
        
        # Start real-time monitoring
        self.start_monitoring()
        
        # Clear temp files first
        files_removed, space_cleared = self.clear_temp_files()
        results.append(f"Cleaned {files_removed} temporary files ({space_cleared / 1024 / 1024:.2f} MB)")
        
        # Clean registry
        registry_cleaned = self.clean_registry()
        results.extend(registry_cleaned)
        
        # Original scans
        results.extend(self.scan_processes())
        results.extend(self.check_startup_entries())
        results.extend(self.check_network_connections())
        
        # New enhanced scans
        results.extend(self.detect_rootkits())
        
        # Advanced memory scanning
        print("\n[*] Performing advanced memory analysis...")
        for proc in psutil.process_iter(['pid', 'name']):
            try:
                # Regular memory scan
                memory_scan_result = self.scan_memory(proc.info['pid'])
                if memory_scan_result:
                    results.append(memory_scan_result)
                
                # Advanced memory scan
                adv_memory_results = self.advanced_memory_scan(proc.info['pid'])
                results.extend(adv_memory_results)
                
                # Behavioral analysis
                behavior_results = self.behavioral_analysis(proc.info['pid'])
                results.extend(behavior_results)
            except:
                continue

        # Scan directories
        directories_to_scan = [
            os.path.join(os.environ['USERPROFILE'], 'Downloads'),
            os.path.join(os.environ['USERPROFILE'], 'Documents'),
            os.path.expandvars('%TEMP%'),
            r"C:\Windows\System32",
            r"C:\Windows\SysWOW64"
        ]
        
        for directory in directories_to_scan:
            results.extend(self.scan_directory(directory))
        
        # Save results
        self.save_results(results)
        
        print("\n[+] Advanced scan complete!")
        return results

    def save_results(self, results):
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"scan_results_{timestamp}.txt"
        
        with open(filename, 'w') as f:
            f.write("Malware Scan Results\n")
            f.write("===================\n\n")
            f.write(f"Scan Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            
            if results:
                for result in results:
                    f.write(f"{result}\n")
            else:
                f.write("No suspicious items found.\n")
                
        print(f"\n[+] Results saved to {filename}") 

    def emergency_cleanup(self):
        """Emergency cleanup function for infected systems"""
        print("\n[!] Starting emergency cleanup...")
        
        # Kill suspicious processes
        for proc in psutil.process_iter(['pid', 'name']):
            try:
                if proc.info['name'].lower() in self.suspicious_processes:
                    proc.kill()
                    print(f"Terminated suspicious process: {proc.info['name']}")
            except:
                continue
        
        # Clear temp files
        self.clear_temp_files()
        
        # Clean registry
        self.clean_registry()
        
        # Flush DNS cache
        subprocess.run(['ipconfig', '/flushdns'], capture_output=True)
        
        # Reset Windows Firewall
        subprocess.run(['netsh', 'advfirewall', 'reset'], capture_output=True)
        
        print("[+] Emergency cleanup completed!")

    def reset_network_adapters(self):
        """Reset all network adapters and clear network-related caches"""
        cleaned = []
        
        try:
            print("\n[*] Resetting network adapters and cache...")
            
            # Release and renew IP
            subprocess.run(['ipconfig', '/release'], capture_output=True)
            time.sleep(2)  # Wait for release
            subprocess.run(['ipconfig', '/renew'], capture_output=True)
            cleaned.append("Released and renewed IP addresses")

            # Flush DNS cache
            subprocess.run(['ipconfig', '/flushdns'], capture_output=True)
            cleaned.append("Flushed DNS cache")

            # Reset Winsock catalog
            subprocess.run(['netsh', 'winsock', 'reset'], capture_output=True)
            cleaned.append("Reset Winsock catalog")

            # Reset TCP/IP stack
            subprocess.run(['netsh', 'int', 'ip', 'reset'], capture_output=True)
            cleaned.append("Reset TCP/IP stack")

            # Clear routing table
            subprocess.run(['route', '/f'], capture_output=True)
            cleaned.append("Cleared routing table")

            # Reset Windows Firewall
            subprocess.run(['netsh', 'advfirewall', 'reset'], capture_output=True)
            cleaned.append("Reset Windows Firewall")

            # Clear network-related registry keys
            network_reg_locations = [
                (winreg.HKEY_LOCAL_MACHINE, r"SYSTEM\CurrentControlSet\Services\Tcpip\Parameters"),
                (winreg.HKEY_LOCAL_MACHINE, r"SYSTEM\CurrentControlSet\Services\DNSCache\Parameters"),
                (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkList\Profiles"),
            ]

            for hkey, location in network_reg_locations:
                try:
                    key = winreg.OpenKey(hkey, location, 0, winreg.KEY_ALL_ACCESS)
                    info = winreg.QueryInfoKey(key)
                    for i in range(info[1]):
                        try:
                            name, value, _ = winreg.EnumValue(key, 0)
                            winreg.DeleteValue(key, name)
                        except:
                            continue
                    winreg.CloseKey(key)
                    cleaned.append(f"Cleaned network registry: {location}")
                except:
                    continue

            print("[+] Network adapters and cache reset complete!")
            print("[!] System restart recommended for changes to take full effect")
            
        except Exception as e:
            logging.error(f"Error resetting network: {str(e)}")
            
        return cleaned

    def clear_all_cache(self):
        """Clear all system and application caches"""
        cleaned = []
        
        try:
            print("\n[*] Clearing all system caches...")
            
            # System caches
            cache_locations = {
                'Windows': [
                    os.path.join(os.environ['SYSTEMROOT'], 'Temp'),
                    os.path.join(os.environ['SYSTEMROOT'], 'Prefetch'),
                    r'C:\Windows\SoftwareDistribution\Download',
                    r'C:\Windows\LiveKernelReports',
                    r'C:\Windows\System32\FNTCACHE.DAT',
                ],
                'User': [
                    os.path.expandvars('%TEMP%'),
                    os.path.expandvars('%TMP%'),
                    os.path.join(os.environ['LOCALAPPDATA'], 'Temp'),
                    os.path.join(os.environ['USERPROFILE'], 'AppData', 'Local', 'Microsoft', 'Windows', 'INetCache'),
                    os.path.join(os.environ['USERPROFILE'], 'AppData', 'Local', 'Microsoft', 'Windows', 'Explorer', 'IconCache.db'),
                ],
                'Store Apps': [
                    os.path.join(os.environ['LOCALAPPDATA'], 'Packages'),
                ],
            }

            # Clear system caches
            for category, locations in cache_locations.items():
                print(f"\n[*] Clearing {category} cache...")
                for location in locations:
                    cleaned.extend(self._clean_location(location))

            # Clear system restore points (optional, use with caution)
            try:
                subprocess.run(['vssadmin', 'delete', 'shadows', '/all', '/quiet'], capture_output=True)
                cleaned.append("Cleared system restore points")
            except:
                pass

            # Clear Windows update cache
            try:
                subprocess.run(['net', 'stop', 'wuauserv'], capture_output=True)
                subprocess.run(['net', 'stop', 'bits'], capture_output=True)
                shutil.rmtree(r'C:\Windows\SoftwareDistribution', ignore_errors=True)
                os.makedirs(r'C:\Windows\SoftwareDistribution')
                subprocess.run(['net', 'start', 'wuauserv'], capture_output=True)
                subprocess.run(['net', 'start', 'bits'], capture_output=True)
                cleaned.append("Cleared Windows Update cache")
            except:
                pass

            # Clear thumbnail cache
            try:
                subprocess.run(['taskkill', '/F', '/IM', 'explorer.exe'], capture_output=True)
                thumbnail_cache = os.path.join(os.environ['LOCALAPPDATA'], 'Microsoft', 'Windows', 'Explorer', 'thumbcache_*.db')
                for file in glob.glob(thumbnail_cache):
                    try:
                        os.remove(file)
                        cleaned.append(f"Removed thumbnail cache: {file}")
                    except:
                        continue
                subprocess.Popen('explorer.exe')
            except:
                pass

            print("[+] Cache clearing complete!")
            
        except Exception as e:
            logging.error(f"Error clearing cache: {str(e)}")
            
        return cleaned

    def monitor_usb_drives(self):
        """Monitor for USB drive insertions and scan them automatically"""
        self.usb_monitoring = True
        
        def get_removable_drives():
            drives = []
            for letter in string.ascii_uppercase:
                drive = f"{letter}:\\"
                try:
                    if os.path.exists(drive) and win32file.GetDriveType(drive) == win32file.DRIVE_REMOVABLE:
                        drives.append(drive)
                except:
                    continue
            return drives

        def monitor_thread():
            initial_drives = set(get_removable_drives())
            
            while self.usb_monitoring:
                current_drives = set(get_removable_drives())
                new_drives = current_drives - initial_drives
                
                for drive in new_drives:
                    print(f"\n[!] New USB drive detected: {drive}")
                    self.scan_directory(drive)
                    
                initial_drives = current_drives
                time.sleep(2)

        self.usb_thread = Thread(target=monitor_thread)
        self.usb_thread.daemon = True
        self.usb_thread.start()

    def stop_usb_monitoring(self):
        """Stop USB monitoring"""
        self.usb_monitoring = False
        if self.usb_thread:
            self.usb_thread.join()

    def analyze_memory_dump(self):
        """Analyze system memory dumps for suspicious patterns"""
        results = []
        
        if not VOLATILITY_AVAILABLE:
            print("[!] volatility3 module not available. Using basic memory analysis...")
            # Basic memory analysis without volatility
            for proc in psutil.process_iter(['pid', 'name', 'memory_info']):
                try:
                    if proc.info['name'].lower() in self.suspicious_processes:
                        results.append(f"Suspicious process found: {proc.info['name']} (PID: {proc.info['pid']})")
                    if proc.info['memory_info'].rss > 1000000000:  # More than 1GB
                        results.append(f"High memory usage process: {proc.info['name']} (PID: {proc.info['pid']})")
                except:
                    continue
            return results
            
        # Original volatility implementation
        dump_locations = [
            os.path.join(os.environ['SystemRoot'], 'MEMORY.DMP'),
            os.path.join(os.environ['SystemRoot'], 'Minidump'),
        ]
        
        print("\n[*] Analyzing memory dumps...")
        for location in dump_locations:
            if os.path.exists(location):
                try:
                    # Use volatility3 for memory analysis
                    vol = volatility3.framework.contexts.Context()
                    config = {'location': location}
                    
                    # Scan for processes
                    procs = volatility3.plugins.windows.pslist.PsList(vol, config)
                    for proc in procs.run():
                        if proc.ImageFileName.lower() in self.suspicious_processes:
                            results.append(f"Suspicious process found in memory dump: {proc.ImageFileName}")
                    
                    # Scan for network connections
                    nets = volatility3.plugins.windows.netscan.NetScan(vol, config)
                    for conn in nets.run():
                        if any(ip in conn.ForeignAddr for ip in self.malicious_ip_ranges):
                            results.append(f"Suspicious network connection in memory: {conn.ForeignAddr}")
                    
                except Exception as e:
                    logging.error(f"Error analyzing memory dump: {str(e)}")
                    
        return results

    def scan_scheduled_tasks(self):
        """Scan for suspicious scheduled tasks"""
        results = []
        print("\n[*] Scanning scheduled tasks...")
        try:
            # Get all scheduled tasks
            output = subprocess.check_output(['schtasks', '/query', '/fo', 'CSV'], text=True)
            tasks = output.splitlines()[1:]  # Skip header
            
            for task in tasks:
                task_parts = task.split(',')
                if len(task_parts) > 1:
                    task_name = task_parts[0].strip('"')
                    task_path = task_parts[-1].strip('"')
                    
                    # Check for suspicious paths or names
                    if any(susp in task_path.lower() for susp in ['temp', 'appdata', 'startup']):
                        results.append(f"Suspicious scheduled task found: {task_name} -> {task_path}")
                        
                    # Check if the task executable exists
                    if not os.path.exists(task_path) and task_path.endswith(('.exe', '.bat', '.ps1')):
                        results.append(f"Scheduled task points to missing file: {task_name} -> {task_path}")
                        
        except Exception as e:
            logging.error(f"Error scanning scheduled tasks: {str(e)}")
            
        return results

    def scan_alternate_data_streams(self):
        """Scan for suspicious alternate data streams"""
        results = []
        print("\n[*] Scanning for alternate data streams...")
        
        def check_ads(filepath):
            try:
                streams = win32file.FindStreams(filepath)
                for stream in streams:
                    if stream.endswith(':Zone.Identifier'):
                        continue  # Skip legitimate Zone.Identifier streams
                    results.append(f"Suspicious alternate data stream found: {filepath} -> {stream}")
            except:
                pass
        
        for drive in self.drives:
            for root, _, files in os.walk(drive):
                for file in files:
                    filepath = os.path.join(root, file)
                    check_ads(filepath)
                    
        return results

    def verify_drivers(self):
        """Verify system drivers for digital signatures"""
        results = []
        print("\n[*] Verifying system drivers...")
        
        try:
            driver_dir = os.path.join(os.environ['SystemRoot'], 'System32', 'drivers')
            for file in os.listdir(driver_dir):
                if file.endswith('.sys'):
                    filepath = os.path.join(driver_dir, file)
                    try:
                        # Check digital signature
                        sign_info = win32security.CryptQueryObject(
                            win32security.CERT_QUERY_OBJECT_FILE,
                            filepath,
                            win32security.CERT_QUERY_CONTENT_FLAG_ALL,
                            win32security.CERT_QUERY_FORMAT_FLAG_ALL,
                            0
                        )
                        if not sign_info:
                            results.append(f"Unsigned driver found: {file}")
                    except:
                        results.append(f"Failed to verify driver signature: {file}")
                        
        except Exception as e:
            logging.error(f"Error verifying drivers: {str(e)}")
            
        return results

    def cleanup(self):
        """Cleanup method to be called when scanner is closed"""
        self.stop_usb_monitoring()

def main():
    scanner = MalwareScanner()
    
    # Request admin rights
    if not scanner.get_admin_rights():
        scanner.console.print("[red]This program requires administrative privileges[/]")
        sys.exit(1)
    
    scanner.console.print(Panel.fit(
        "[cyan]Advanced Malware Scanner[/]\n" +
        f"System: {platform.platform()}\n" +
        f"Python: {platform.python_version()}",
        title="System Information"
    ))
    
    try:
        while True:
            choice = scanner.display_menu()
            
            if choice == "1":
                scanner.quick_scan()
            elif choice == "2":
                scanner.full_scan()
            elif choice == "3":
                scanner.custom_scan()
            elif choice == "4":
                scanner.emergency_cleanup()
            elif choice == "5":
                scanner.system_optimization()
            elif choice == "6":
                scanner.view_scan_history()
            elif choice == "7":
                scanner.console.print("[yellow]Exiting...[/]")
                break
                
    except KeyboardInterrupt:
        scanner.console.print("\n[yellow]Scanner terminated by user[/]")
    finally:
        if scanner.monitoring:
            scanner.stop_monitoring()

if __name__ == "__main__":
    main()